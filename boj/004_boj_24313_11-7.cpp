/***********************************************
 * 2025-07-28
 ***********************************************/

#include <bits/stdc++.h>
using namespace std;

#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#define endl '\n'

int main() {
    fastio;
    int a1, a0;
    cin >> a1 >> a0;
    int c, n0;
    cin >> c >> n0;

    // O(n)의 정의를 만족하는지 보라했으므로 O(g(n)) = O(n) 이라는 뜻이고, 이는 g(n) = n일 때 빅 오 표기법에 만족하는지 보라는것.

    // 빅 오 표기법에 만족하려면 fn이 항상 c*gn보다 작거나 같아야 함.

    //문제에서
    // fn = a1 * n + a0
    // gn = n 
    // 라고 했으니

    // fn <= c * gn
    // a1 * n + a0 <= c * gn에 항상 만족하는지 보라는 것임.
    
    // 이 식은, 임의의 n을 대입했을때 fn이라는 직선의 함숫값보다 c*gn이라는 직선의 함숫값이 항상 크거나 같음을 입증하라는것임.
    // 생각해보면, 두가지 조건을 만족해야 함.
        // n0라는 시점 이후로 겹치는 지점이 있으면 안됨.(겹치면 대소관계가 변하는 지점이라는거니까)
        // c*gn라는 직선의 기울기가 fn이라는 직선의 기울기보다 무조건 크거나 같아야함.
        
        // 즉 기울기가 크거나 같은 동시에 n0라는 시점에 함숫값도 크거나 같아야함.
    
    // == 두가지 조건 ==
    // n0인 시점에 함숫값은 a1 * n0 + a0 과 c * n0 인데, c * n0가 크거나 같아야함.
        // a1 * n0 + a0 <= c * n0
    // c*gn의 기울기는 c가 양수이므로 항상 우측 위로 향하는 기울기임.
        // fn의 기울기(a1)는 c보다 작거나 같기만 하면 됨.
        // a1 <= c

    // 이제 위 두 조건을 코드로 쓰면

    if(a1 * n0 + a0 <= c * n0 && a1 <= c){
        cout << 1 << endl;
    }
    else{
        cout << 0 << endl;
    }
    return 0;
}